---
sidebar_position: 2
---

# Define RPC Methods and Messages

## Step 1: Defining Methods and Messages

Proceed to open the **src/Protobuf/contract/lottery_game_contract.proto** and overwrite the existing file contents with the following code snippet.

```protobuf showLineNumbers
syntax = "proto3";

import "aelf/core.proto";
import "aelf/options.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/wrappers.proto";
import "Protobuf/reference/acs12.proto";
// The namespace of this class
option csharp_namespace = "AElf.Contracts.LotteryGame";

service LotteryGame {
  // The name of the state class the smart contract is going to use to access blockchain state
  option (aelf.csharp_state) = "AElf.Contracts.LotteryGame.LotteryGameState";
  option (aelf.base) = "Protobuf/reference/acs12.proto";

  rpc Initialize (google.protobuf.Empty) returns (google.protobuf.Empty) {
  }

  rpc Play (google.protobuf.Int64Value) returns (google.protobuf.Empty) {
  }

  rpc Withdraw (google.protobuf.Int64Value) returns (google.protobuf.Empty) {
  }

  rpc Deposit (google.protobuf.Int64Value) returns (google.protobuf.Empty) {
  }
  
  rpc TransferOwnership (aelf.Address) returns (google.protobuf.Empty) {
  }

  rpc GetPlayAmountLimit (google.protobuf.Empty) returns (PlayAmountLimitMessage) {
    option (aelf.is_view) = true;
  }

  rpc GetContractBalance (google.protobuf.Empty) returns (google.protobuf.Int64Value) {
    option (aelf.is_view) = true;
  }
  
  rpc GetOwner (google.protobuf.Empty) returns (google.protobuf.StringValue) {
    option (aelf.is_view) = true;
  }
}

// An event that will be emitted from contract method call when Play is called.
message PlayOutcomeEvent {
  option (aelf.is_event) = true;
  int64 amount = 1;
  int64 won = 2;
}

// An event that will be emitted from contract method call when Withdraw is called.
message WithdrawEvent {
  option (aelf.is_event) = true;
  int64 amount = 1;
  aelf.Address from = 2;
  aelf.Address to = 3;
}

// An event that will be emitted from contract method call when Deposit is called.
message DepositEvent {
  option (aelf.is_event) = true;
  int64 amount = 1;
  aelf.Address from = 2;
  aelf.Address to = 3;
}

// The message containing the play amount limits
message PlayAmountLimitMessage {
  int64 minimumAmount = 1;
  int64 maximumAmount = 2;
}
```

## Step 2: Understanding the Code

**Interface declarations**:
- **Initialize** - Initialises the owner of the contract as well as the reference to the Multitoken Contract. 
- **Play** - The method to be called by the player when they intend to make a draw. This will either pay out to the player or deduct tokens from them.
- **Withdraw** - Withdraws a specified amount of tokens from the contract's token pool. This can only be called by the contract owner.
- **Deposit** - Deposits a specified amount of tokens to the contract to act as the token pool. This can only be called by the contract owner.
- **TransferOwnership** - Transfer ownership of the contract to another address. This can only be called by the contract owner.
- **GetPlayAmountLimit** - Returns the minimum and maximum limit to the amount of tokens players can use to play per session.
- **GetContractBalance** - Returns the current balance of the token pool.
- **GetOwner** - Returns the current owner of the LotteryGame contract.
  
**Message definitions**:

- **PlayOutcomeEvent** - The event that will be emitted to reflect the Play outcome.
- **WithdrawEvent** - The event that will be emitted to reflect the Withdraw outcome, including the amount of tokens withdrawn and the receiver address.
- **DepositEvent** - The event that will be emitted to reflect the Deposit outcome, including the amount of tokens deposited into the token pool and the sender address.
- **PlayAmountLimitMessage** - The message that contains the play amount upper and lower limit per session.

With the interface declarations and message definitions, let's go on to define our smart contract states in the next section.