---
sidebar_position: 3
---

# Unit Test Voting Smart Contract Logic

It is advice to create a Unit Text for the Smart Contract before it is deployed to the Aelf blockchain. The Unit Test not just help us to verify the Smart Contract is free from bugs, it is also gives us the opportunity to review our code before it is deployed.

In this step, we will be writing the unit test of our Voting Smart Contract in the **test/BuildersDAOTests.cs** file!

Proceed to overwrite the existing contents of **test/BuildersDAOTests.cs** file with the following code snippet.

## Implementing Unit Test for Initialize

The Initialize method is to initialize the Smart Contract, we pass a empty parameter, Then will initialize a Proposals,
and set `State.Initialized.Value` as true. For positive case, we call the initialize once, then verify whether the transaction result is `Mined`.
For negative case, we call the initialize twice, when we make the second call, it will throw an exception containing `already initialized`.

```csharp showLineNumbers
[Fact]
public async Task InitializeTest_Success()
{
    // The Initialize method is to initialize the Smart Contract
    var res = await BuildersDAOStub.Initialize.SendAsync(new Empty());
    // The result should be Mined
    res.TransactionResult.Status.ToString().ShouldBe("Mined");
}

[Fact]
public async Task InitializeTest_Duplicate()
{
    // The Initialize method is to initialize the Smart Contract
    await BuildersDAOStub.Initialize.SendAsync(new Empty());
    try
    {
        // If repeated call Initialize method, it will throw an exception
        await BuildersDAOStub.Initialize.SendAsync(new Empty());
    }
    catch (Exception e)
    {
        e.Message.ShouldContain("already initialized");
    }
}
```

## Implementing Unit Test for JoinDAO

The JoinDAO method is to join the StackUpDAO so that users can use the subsequent methods, we pass the address as a parameter, Then call the method,
and set `State.Members[input] = true`. For positive case, we call the JoinDAO with Account[1] and Account[2], then verify whether the transaction result is `Mined`.
For negative case, we call the initialize with Account[1] twice, when we make the second call, it will throw an exception containing `Member is already in the DAO`.

:::tip
If you haven't completed the implementation of JoinDAO method, when you run this unit test method, it will fail.
The implementation code being referenced is provided in the latter part; you can refer to it, and check if your implementation matches the reference code.
:::

```csharp showLineNumbers
[Fact]
public async Task JoinDAOTest_Success()
{
    // Mock the Initialize step
    await InitializeTest_Success();
    // After we have initialized the BuildsDAO smart contract, we simulate two participants by calling the JoinDAO methods two times with two different accounts
    var res1 = await BuildersDAOStub.JoinDAO.SendAsync(Accounts[1].Address);
    var res2 = await BuildersDAOStub.JoinDAO.SendAsync(Accounts[2].Address);
    // The result should be Mined
    res1.TransactionResult.Status.ToString().ShouldBe("Mined");
    res2.TransactionResult.Status.ToString().ShouldBe("Mined");
}

[Fact]
public async Task JoinDAOTest_Duplicate()
{
    // Mock the Initialize step
    await InitializeTest_Success();
    await BuildersDAOStub.JoinDAO.SendAsync(Accounts[1].Address);
    try
    {
        // If repeated call JoinDAO method with the same account, it will throw an exception
        await BuildersDAOStub.JoinDAO.SendAsync(Accounts[1].Address);
    }
    catch (Exception e)
    {
        e.Message.ShouldContain("Member is already in the DAO");
    }
}
```

## Implementing Unit Test for CreateProposal
The CreateProposal method is to create a proposal. We have separately written a `CreateProposal` method, where users pass an address as a parameter to create proposal,
and then return this proposal. For positive case, we will call CreateProposal with Account[1], then the title of result should be the same as input.
For negative case, we will call CreateProposal with Account[2], it will throw an exception containing `Only DAO members can create proposals`.

```csharp showLineNumbers
[Fact]
public async Task CreateProposalTest_Success()
{
    // Mock the Initialize, JoinDAO steps
    await JoinDAOTest_Success();
    // Creates a proposal with the first account.
    var proposal = await CreateProposal(Accounts[1].Address);
    // The result should be the same as input
    proposal.Title.ShouldBe("proposal test");
}

private async Task<Proposal> CreateProposal(Address creator)
{
    var createProposalInput = new CreateProposalInput
    {
        Creator = creator,
        Description = "proposal test",
        Title = "proposal test",
        VoteThreshold = 1
    };
    var proposal = await BuildersDAOStub.CreateProposal.SendAsync(createProposalInput);
    return proposal.Output;
}

[Fact]
public async Task CreateProposalTest_NoPermission()
{
    // Mock the Initialize, JoinDAO steps
    await JoinDAOTest_Success();
    try
    {
        // If call CreateProposal method without the first account, it will throw an exception
        await CreateProposal(Accounts[2].Address);
    }
    catch (Exception e)
    {
        e.Message.ShouldContain("Only DAO members can create proposals");
    }
}
```

## Implementing Unit Test for VoteOnProposal

The VoteOnProposal method is to vote for proposal. We need to call the previous method to mock the data we need.
Then call the VoteOnProposal method with Account[1] and Account[2], and Account[1] voted for the `Vote = true` option,
Account[2] voted for the `Vote = false` option, and the results should be mined. For positive case,
we will call VoteOnProposal with Account[1] and Account[2], then verify whether the transaction results are `Mined`.
For negative cases, one is we will call VoteOnProposal with Account[3], it will throw an exception containing `Only DAO members can vote`.
Another one is call VoteOnProposal with the wrong ProposalId, it will throw an exception containing `Proposal not found`.

```csharp showLineNumbers
[Fact]
public async Task VoteOnProposalTest_Success()
{
    // Mock the Initialize, JoinDAO steps
    await JoinDAOTest_Success();
    // Mock the CreateProposal step
    var proposal = await CreateProposal(Accounts[1].Address);
    // Vote the created proposal with the two accounts.
    var voteInput1 = new VoteInput
    {
        ProposalId = proposal.Id,
        Vote = true,
        Voter = Accounts[1].Address
    };
    // The result should be Mined
    var res1 = await BuildersDAOStub.VoteOnProposal.SendAsync(voteInput1);
    var voteInput2 = new VoteInput
    {
        ProposalId = proposal.Id,
        Vote = false,
        Voter = Accounts[2].Address
    };
    var res2 = await BuildersDAOStub.VoteOnProposal.SendAsync(voteInput2);
    res1.TransactionResult.Status.ToString().ShouldBe("Mined");
    res2.TransactionResult.Status.ToString().ShouldBe("Mined");
}

[Fact]
public async Task VoteOnProposalTest_NoPermission()
{
    // Mock the Initialize, JoinDAO steps
    await JoinDAOTest_Success();
    // Mock the CreateProposal step
    var proposal = await CreateProposal(Accounts[1].Address);
    var voteInput1 = new VoteInput
    {
        ProposalId = proposal.Id,
        Vote = true,
        Voter = Accounts[3].Address
    };
    try
    {
        // If call VoteOnProposal method with an account who does not have called JoinDAO, it will throw an exception
        await BuildersDAOStub.VoteOnProposal.SendAsync(voteInput1);
    }
    catch (Exception e)
    {
        e.Message.ShouldContain("Only DAO members can vote");
    }
}

[Fact]
public async Task VoteOnProposalTest_NoProposal()
{
    // Mock the Initialize, JoinDAO steps
    await JoinDAOTest_Success();
    // Mock the CreateProposal step
    var proposal = await CreateProposal(Accounts[1].Address);
    var voteInput1 = new VoteInput
    {
        ProposalId = "123",
        Vote = true,
        Voter = Accounts[1].Address
    };
    try
    {
        // If call VoteOnProposal method with a ProposalId that does not have called CreateProposal, it will throw an exception
        await BuildersDAOStub.VoteOnProposal.SendAsync(voteInput1);
    }
    catch (Exception e)
    {
        e.Message.ShouldContain("Proposal not found");
    }
}
```

## Implementing Unit Test for GetAllProposals

The GetAllProposals method is to get all the proposal results. We can call this method to get results of proposal.
For positive case, we call the GetAllProposals, then verify whether the number of proposal is two, and one of the options is yes,
and another one is no. For this method, it doesn't have negative case.

:::tip
If you haven't completed the implementation of GetAllProposals method, when you run this unit test method, it will fail.
The implementation code being referenced is provided in the latter part; you can refer to it, and check if your implementation matches the reference code.
:::

```csharp showLineNumbers
[Fact]
public async Task GetAllProposalsTest()
{
    // Mock the Initialize, JoinDAO, CreateProposal, VoteOnProposal steps
    await VoteOnProposalTest_Success();
    // Gets all the proposals
    var proposalResult = await BuildersDAOStub.GetAllProposals.CallAsync(new Empty());
    // The result should be same as input
    proposalResult.Proposals[1].YesVotes.ShouldContain(Accounts[1].Address);
    proposalResult.Proposals[1].NoVotes.ShouldContain(Accounts[2].Address);
}
```

After that, run ``dotnet test`` command to execute this unit test case, and check the result.

You should see the following output from terminal:

![result](/img/unit-test-output.png)


**Understanding the Code**

In these code snippet, we run the unit test in sequence.

We will then verify the steps with the **ShouldBe, ShouldContain** SDK methods with expected outcomes of the Unit Test.