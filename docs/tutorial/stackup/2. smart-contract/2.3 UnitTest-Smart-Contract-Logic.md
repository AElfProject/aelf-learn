---
sidebar_position: 3
---

# Unit Test Voting Smart Contract Logic

It is advice to create a Unit Text for the Smart Contract before it is deployed to the Aelf blockchain. The Unit Test not just help us to verify the Smart Contract is free from bugs, it is also gives us the opportunity to review our code before it is deployed.

In this step, we will be writing the unit test of our Voting Smart Contract in the **test/BuildersDAOTests.cs** file!

Proceed to overwrite the existing contents of **test/BuildersDAOTests.cs** file with the following code snippet.

## Implementing Unit Test for Initialize

The Initialize method is to initialize the Smart Contract. It will initialize a proposal in the method.

In this method, we pass a empty parameter, and initialize a proposal called `Proposal #1`.

**Positive cases**

We call the initialize once, then verify whether the transaction result is `Mined`.

We can use `ShouldBe` method to judge the the value of `transactionResult.Status`.

**Negative cases**

We call the initialize twice, when we make the second call, it will throw an exception containing `already initialized`.

We can use `ShouldContain` method to judge the the message content of Exception.

```csharp showLineNumbers
[Fact]
public async Task InitializeTest_Success()
{
    // The Initialize method is to initialize the Smart Contract
    var res = await BuildersDAOStub.Initialize.SendAsync(new Empty());
    // The result should be Mined
    res.TransactionResult.Status.ToString().ShouldBe("Mined");
}

[Fact]
public async Task InitializeTest_Duplicate()
{
    // The Initialize method is to initialize the Smart Contract
    await BuildersDAOStub.Initialize.SendAsync(new Empty());
    try
    {
        // If repeated call Initialize method, it will throw an exception
        await BuildersDAOStub.Initialize.SendAsync(new Empty());
    }
    catch (Exception e)
    {
        e.Message.ShouldContain("already initialized");
    }
}
```

## Implementing Unit Test for JoinDAO

The JoinDAO method is to join the StackUpDAO so that users can use the subsequent methods, 

In this method, we pass the address as a parameter. Then call the method, and set `State.Members[input] = true`. 

**Positive cases**

We call the JoinDAO with Account[1] and Account[2], then verify whether the transaction result is `Mined`.

We can use `ShouldBe` method to judge the the value of `transactionResult.Status`.

**Negative cases**

We call the initialize with Account[1] twice, when we make the second call, it will throw an exception containing `Member is already in the DAO`.

We can use `ShouldContain` method to judge the the message content of Exception.

:::tip
If you haven't completed the implementation of JoinDAO method, when you run this unit test method, it will fail.
The implementation code being referenced is provided in the latter part; you can refer to it, and check if your implementation matches the reference code.
:::

```csharp showLineNumbers
[Fact]
public async Task JoinDAOTest_Success()
{
    // Mock the Initialize step
    await InitializeTest_Success();
    // After we have initialized the BuildsDAO smart contract, we simulate two participants by calling the JoinDAO methods two times with two different accounts
    var res1 = await BuildersDAOStub.JoinDAO.SendAsync(Accounts[1].Address);
    var res2 = await BuildersDAOStub.JoinDAO.SendAsync(Accounts[2].Address);
    // The result should be Mined
    res1.TransactionResult.Status.ToString().ShouldBe("Mined");
    res2.TransactionResult.Status.ToString().ShouldBe("Mined");
}

[Fact]
public async Task JoinDAOTest_Duplicate()
{
    // Mock the Initialize step
    await InitializeTest_Success();
    await BuildersDAOStub.JoinDAO.SendAsync(Accounts[1].Address);
    try
    {
        // If repeated call JoinDAO method with the same account, it will throw an exception
        await BuildersDAOStub.JoinDAO.SendAsync(Accounts[1].Address);
    }
    catch (Exception e)
    {
        e.Message.ShouldContain("Member is already in the DAO");
    }
}
```

## Implementing Unit Test for CreateProposal

The CreateProposal method is to create a proposal. 

We have separately written a `CreateProposal` method, where users pass an address as a parameter to create proposal, and then return this proposal.

**Positive cases**

We will call CreateProposal with Account[1], then the title of result should be the same as input.

We can use `ShouldBe` method to judge the the result of CreateProposal method.

**Negative cases**

We will call CreateProposal with Account[2], it will throw an exception containing `Only DAO members can create proposals`.

We can use `ShouldContain` method to judge the the message content of Exception.

```csharp showLineNumbers
[Fact]
public async Task CreateProposalTest_Success()
{
    // Mock the Initialize, JoinDAO steps
    await JoinDAOTest_Success();
    // Creates a proposal with the first account.
    var proposal = await CreateProposal(Accounts[1].Address);
    // The result should be the same as input
    proposal.Title.ShouldBe("proposal test");
}

private async Task<Proposal> CreateProposal(Address creator)
{
    var createProposalInput = new CreateProposalInput
    {
        Creator = creator,
        Description = "proposal test",
        Title = "proposal test",
        VoteThreshold = 1
    };
    var proposal = await BuildersDAOStub.CreateProposal.SendAsync(createProposalInput);
    return proposal.Output;
}

[Fact]
public async Task CreateProposalTest_NoPermission()
{
    // Mock the Initialize, JoinDAO steps
    await JoinDAOTest_Success();
    try
    {
        // If call CreateProposal method without the first account, it will throw an exception
        await CreateProposal(Accounts[2].Address);
    }
    catch (Exception e)
    {
        e.Message.ShouldContain("Only DAO members can create proposals");
    }
}
```

## Implementing Unit Test for VoteOnProposal

The VoteOnProposal method is to vote for proposal. 

We need to call the previous method to mock the data we need. Then call the VoteOnProposal method with Account[1] and Account[2], and Account[1] voted for the `Vote = true` option,
Account[2] voted for the `Vote = false` option, and the results should be `Mined`.

**Positive cases**

We will call VoteOnProposal with Account[1] and Account[2], then verify whether the transaction results are `Mined`.

We can use `ShouldBe` method to judge the the value of `transactionResult.Status`.

**Negative cases**

First case is we will call VoteOnProposal with Account[3], it will throw an exception containing `Only DAO members can vote`.
Another case is call VoteOnProposal with the wrong ProposalId, it will throw an exception containing `Proposal not found`.

We can use `ShouldContain` method to judge the the message content of Exception.

```csharp showLineNumbers
[Fact]
public async Task VoteOnProposalTest_Success()
{
    // Mock the Initialize, JoinDAO steps
    await JoinDAOTest_Success();
    // Mock the CreateProposal step
    var proposal = await CreateProposal(Accounts[1].Address);
    // Vote the created proposal with the two accounts.
    var voteInput1 = new VoteInput
    {
        ProposalId = proposal.Id,
        Vote = true,
        Voter = Accounts[1].Address
    };
    // The result should be Mined
    var res1 = await BuildersDAOStub.VoteOnProposal.SendAsync(voteInput1);
    var voteInput2 = new VoteInput
    {
        ProposalId = proposal.Id,
        Vote = false,
        Voter = Accounts[2].Address
    };
    var res2 = await BuildersDAOStub.VoteOnProposal.SendAsync(voteInput2);
    res1.TransactionResult.Status.ToString().ShouldBe("Mined");
    res2.TransactionResult.Status.ToString().ShouldBe("Mined");
}

[Fact]
public async Task VoteOnProposalTest_NoPermission()
{
    // Mock the Initialize, JoinDAO steps
    await JoinDAOTest_Success();
    // Mock the CreateProposal step
    var proposal = await CreateProposal(Accounts[1].Address);
    var voteInput1 = new VoteInput
    {
        ProposalId = proposal.Id,
        Vote = true,
        Voter = Accounts[3].Address
    };
    try
    {
        // If call VoteOnProposal method with an account who does not have called JoinDAO, it will throw an exception
        await BuildersDAOStub.VoteOnProposal.SendAsync(voteInput1);
    }
    catch (Exception e)
    {
        e.Message.ShouldContain("Only DAO members can vote");
    }
}

[Fact]
public async Task VoteOnProposalTest_NoProposal()
{
    // Mock the Initialize, JoinDAO steps
    await JoinDAOTest_Success();
    // Mock the CreateProposal step
    var proposal = await CreateProposal(Accounts[1].Address);
    var voteInput1 = new VoteInput
    {
        ProposalId = "123",
        Vote = true,
        Voter = Accounts[1].Address
    };
    try
    {
        // If call VoteOnProposal method with a ProposalId that does not have called CreateProposal, it will throw an exception
        await BuildersDAOStub.VoteOnProposal.SendAsync(voteInput1);
    }
    catch (Exception e)
    {
        e.Message.ShouldContain("Proposal not found");
    }
}
```

## Implementing Unit Test for GetAllProposals

The GetAllProposals method is to get all the proposal results. 

We can call this method to get results of proposal.

**Positive cases**

We call the GetAllProposals, then verify whether the number of proposal is two, and one of the options is yes,
and another one is no. For this method, it doesn't have negative case.

:::tip
If you haven't completed the implementation of GetAllProposals method, when you run this unit test method, it will fail.
The implementation code being referenced is provided in the latter part; you can refer to it, and check if your implementation matches the reference code.
:::

```csharp showLineNumbers
[Fact]
public async Task GetAllProposalsTest()
{
    // Mock the Initialize, JoinDAO, CreateProposal, VoteOnProposal steps
    await VoteOnProposalTest_Success();
    // Gets all the proposals
    var proposalResult = await BuildersDAOStub.GetAllProposals.CallAsync(new Empty());
    // The result should be same as input
    proposalResult.Proposals[1].YesVotes.ShouldContain(Accounts[1].Address);
    proposalResult.Proposals[1].NoVotes.ShouldContain(Accounts[2].Address);
}
```

After that, run ``dotnet test`` command to execute this unit test case, and check the result.

You should see the following output from terminal if you implement all the methods and unit tests:

![result](/img/unit-test-output.png)